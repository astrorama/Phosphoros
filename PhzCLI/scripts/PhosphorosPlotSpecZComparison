#! /usr/bin/env python
# Author Nicolas Morisset

import os
import sys
import numpy as np
import matplotlib.pyplot as plt
from astropy.table import Table
import astropy.io.fits as fits
from astropy.vo.samp import SAMPIntegratedClient
import urlparse


def file_exist(file):
    """
    """
    if not os.path.exists(file):  
       print '--> Error File not found : ', file
       print '--> Program aborted!'          
       sys.exit()
    
#
#-------------------------------------------------------------------------------
#

def read_table(filename):
    """
    """
    print '--> Reading file : ', filename
    file_exist(filename)
    try :
        data = Table.read(filename, format='fits')
    except:
        data = Table.read(filename, format='ascii')
    return data
             
          
#
#-------------------------------------------------------------------------------
#


def create_table(files, ids, specz, phz):
    tables = [read_table(f) for f in files]
    for i, t in enumerate(tables):
        if not ids[i] in t.colnames:
            print 'Input catalog', files[i], 'does not have column', ids[i]
            exit()
    id_inter = set.intersection(*[set(t[ids[i]]) for i,t in enumerate(tables)])
    values_map = {}
    all_cols = {}
    orig_ids = []
    for i in id_inter:
        values_map[i] = [None, None]
        all_cols[i] = []
    for i,t in enumerate(tables):
        has_specz = specz in t.colnames
        has_phz = phz in t.colnames
        orig_ids.append([])
        for r in t:
            r_id = r[ids[i]]
            orig_ids[-1].append(r_id)
            if not r_id in id_inter:
                continue
            all_cols[r_id].append(r)
            if has_specz:
                values_map[r_id][0] = r[specz]
            if has_phz:
                values_map[r_id][1] = r[phz]
    i = []
    s = []
    p = []
    for k,v in values_map.iteritems():
        i.append(k)
        s.append(v[0])
        p.append(v[1])
    return Table([i,s,p], names=('ID',specz,phz)), all_cols, orig_ids
    
    
def compute_stats(array, col_number):
    """
    Computes mean, median, sigma and outliers 
    Array contents : sourceIdArr speczArr redshift sedname ebv max
    
    Returns outliers array
    """
    # 
    specZ = array.field(1)
    colZ  = array.field(col_number)
 

    diffArr = colZ - specZ
    plusArr = 1 + specZ  
    dataArr = diffArr / plusArr
    
    mean     = np.average(dataArr)
    median   = np.median(dataArr)
    sigma    = np.std(dataArr)
    
    # Mean absolute deviation
    mad = np.median(abs(dataArr - median)) 
    
    absDataArr = abs(dataArr)
    outliers = [i for i in absDataArr if i > 0.15]
    outliersPercent =  len(outliers)*100. / len(colZ)
 
    # Without outliers
    noOutliersArr   = [i for i in absDataArr if i <= 0.15]
    sigmaNoOutliers = np.std(noOutliersArr)
    meanNoOutliers  = np.average(noOutliersArr)
    
                    
    print '--> Mean                : ', mean     
    print '--> Median              : ', median     
    print '--> Sigma               : ', sigma     
    print '--> Mad                 : ', mad     
    print '--> Outliers            : ', outliersPercent, '%'
    print '--> Sigma (no outliers) : ', sigmaNoOutliers     
   
    return (specZ, colZ, dataArr, mean, median, sigma, mad, outliersPercent, sigmaNoOutliers, meanNoOutliers)

#
#-------------------------------------------------------------------------------
#

class Selector(object):
    
    def __init__(self, fig_list, table, all_cols, pdf_file):
        for fig in fig_list:
            if hasattr(fig, 'canvas'):
                fig.canvas.mpl_connect('pick_event', self.onpick)
        self.fig_list = fig_list
        self.table = table
        self.all_cols = all_cols
        self.have_pdf = os.path.isfile(pdf_file)
        if self.have_pdf:
            print 'Loading 1D PDFs. Please wait...'
            self.hdus = fits.open(pdf_file)
    
    def onpick(self, event):
        if event.mouseevent.button != 1:
            return
        for fig in self.fig_list:
            if hasattr(fig, 'updateSelected'):
                fig.updateSelected(event.ind[0])
        if not event.mouseevent.dblclick:
            return
        id = self.table[event.ind[0]][0]
        print '\nFull info for source with ID',id,':'
        for r in self.all_cols[id]:
            for c in r.colnames:
                print '   ',c,'=',r[c]
        if self.have_pdf:
            hdu = (x for x in self.hdus if 'EXTNAME' in x.header and  x.header['EXTNAME']==str(id)).next()
            f, ax = plt.subplots()
            xs = hdu.data[hdu.columns[0].name]
            ys = hdu.data[hdu.columns[1].name]
            ax.plot(xs, ys)
            ax.set_title('1D PDF for source with ID '+str(id))
            y_lim = ax.get_ylim()
            y_size = y_lim[1]-y_lim[0]
            specz = self.table[event.ind[0]][1]
            ax.plot([specz, specz], y_lim, c='k', alpha=.5)
            ax.text(specz, y_lim[0]+.9*y_size, 'SpecZ', color='k', alpha=.5)
            phz = self.table[event.ind[0]][2]
            ax.plot([phz, phz], y_lim, c='r', alpha=.5)
            ax.text(phz, y_lim[0]+.95*y_size, 'PHZ', color='r', alpha=.5)
            plt.show()
            

#
#-------------------------------------------------------------------------------
#

class SampUpdater(object):

    def __init__(self, tablenames, id_col, table, orig_ids, update_listeners):
        self.topcat = None
        self.update_listeners = update_listeners
        try:
            self.client = SAMPIntegratedClient()
            self.client.connect()
            for c in self.client.get_registered_clients():
                meta = self.client.get_metadata(c)
                if 'samp.name' in meta and meta['samp.name'] == 'topcat':
                    self.topcat = c
        except:
            pass
        if self.topcat:
            self.client.bind_receive_notification('table.highlight.row', self.rowNotification)
            self.table_urls = []
            self.table_ids = []
            self.global_ids = table['ID']
            self.global_ids_reverse = {}
            for i in range(len(self.global_ids)):
                self.global_ids_reverse[self.global_ids[i]] = i
            self.id_col = id_col
            self.orig_ids = orig_ids
            for ti, name in enumerate(tablenames):
                try:
                    data = Table.read(name, format='fits')
                except:
                    continue
                id_map = {}
                for i in range(len(data)):
                    id_map[data[id_col[ti]][i]] = i
                self.table_ids.append(id_map)
                url = 'file:' + os.path.abspath(name)
                table_name = os.path.basename(name)
                self.table_urls.append(url)
                message = {'samp.mtype' : 'table.load.fits',
                           'samp.params' : { 'url' : url,
                                             'name' : table_name }}
                self.client.notify(self.topcat, message)

    def updateSelected(self, i):
        if self.topcat:
            for url, ids in zip(self.table_urls, self.table_ids):
                message = {'samp.mtype' : 'table.highlight.row',
                           'samp.params' : { 'url' : url,
                                             'row' : str(ids[self.global_ids[i]]) }}
                self.client.notify_all(message)

    def rowNotification(self, private_key, sender_id, mtype, params, extra):
        url = params['url']
        if not url in self.table_urls:
            return
        i = self.table_urls.index(url)
        row = int(params['row'])
        id = self.orig_ids[i][row]
        global_row = self.global_ids_reverse[id]
        for l in self.update_listeners:
            l.updateSelected(global_row)

#
#-------------------------------------------------------------------------------
#

def displaySpeczPhotz(ids, specz, photz, data):
    
    z_max = max(max(specz), max(photz)) + 0.1
    data_max = max(max(data), abs(min(data))) + 0.1

    f = plt.figure(figsize=(7, 8))

    # Create the specz-photz plot
    ax1 = plt.subplot2grid((4,3), (0,0), rowspan=3, colspan=3)
    ax1.set_ylabel('PhotoZ')
    # Plot the diagonal
    ax1.plot([-0.1, z_max], [-0.1, z_max], c='k', alpha=0.2)
    # Plot the outlier limits
    x_r = [v/10. for v in range(0,int(z_max*10+1))]
    y1 = [0.15+1.15*x for x in x_r]
    y2 = [-0.15+.85*x for x in x_r]
    ax1.plot(x_r, y1, "r", alpha=.3)
    ax1.plot(x_r, y2, "r", alpha=.3)
    # Plot the data
    ax1.scatter(specz, photz, c='b', marker='o', s=10, edgecolors='none', alpha=0.6, picker=True)
    ax1.set_xlim([-0.1, z_max])
    ax1.set_ylim([-0.1, z_max])

    # Create the Dz/(1+z) plot
    ax2 = plt.subplot2grid((4,3), (3,0), colspan=3)
    ax2.set_ylabel('$\Delta$z/(1+z)')
    ax2.set_xlabel('SpecZ')
    # Plot the zero line
    ax2.plot ([-0.1, z_max], [0, 0], c='k', alpha=0.2)
    # Plot the outlier limits
    ax2.plot ([-0.1, z_max], [0.15, 0.15], c='r', alpha=0.3)
    ax2.plot ([-0.1, z_max], [-0.15, -0.15], c='r', alpha=0.3)
    ax2.scatter(specz, data, c='b', marker='o', s=10, edgecolors='none', alpha=0.6, picker=True)
    ax2.set_xlim([-0.1, z_max])
    ax2.set_ylim([-data_max, data_max])

    f.tight_layout()
    f.subplots_adjust(hspace=0)
    
    id_text = ax1.text(0.05, 0.95, 'selected ID:', transform=ax1.transAxes, va='top')
    selected1 = ax1.scatter(0, 0, c='none', marker='o', s=60, edgecolors='#00EE00', linewidth='2', visible=False)
    selected2 = ax2.scatter(0, 0, c='none', marker='o', s=60, edgecolors='#00EE00', linewidth='2', visible=False)
    def updateSelected(index):
        id_text.set_text('selected ID: %d' % ids[index])
        selected1.set_visible(True)
        selected1.set_offsets([specz[index], photz[index]])
        selected2.set_visible(True)
        selected2.set_offsets([specz[index], data[index]])
        plt.pause(.01)
        f.canvas.draw()
    f.updateSelected = lambda x: updateSelected(x)
    return f

#
#-------------------------------------------------------------------------------
#

def displayHistogram(data, mean, median, mad, sigma, outliersPercent, sigmaNoOutliers, meanNoOutliers):

    f, ax = plt.subplots(figsize=(10, 4)) 

    barValues, bins, patches = plt.hist(data, bins=100)
    ax.axvline(x=0.15, c='r', alpha=.3)
    ax.axvline(x=-0.15, c='r', alpha = .3)
    ax.set_xlabel("Value")
    ax.set_ylabel("Frequency")
    ax.set_title('Distribution of : (PhotoZ - SpecZ)/(1 + SpecZ)')
              
    # Write information
    txt = '\n  Mean : %2.5f\n  Median : %2.5f\n  Mad : %2.5f\n  Sigma : %2.5f\n  Outliers : %2.5f%%\n  Sigma(no outliers) : %2.5f\n  Mean((no outliers) : %2.5f ' \
        % (mean, median, mad, sigma, outliersPercent, sigmaNoOutliers, meanNoOutliers)
    ax.text(ax.get_xlim()[0], ax.get_ylim()[1], txt, fontsize=10, family='sans-serif', style='italic', ha='left', va='top', alpha=.5)
    
    f.tight_layout()
    return f
    
#
#-------------------------------------------------------------------------------
#

def main():
    import argparse
    usage = """
            usage: %prog [options] \n           
            
            Computes the standard deviation of [ (photZ - specZ) / 1+specZ ] and
            the outliers fraction as:
                outliers =  (photZ - specZ) / 1+specZ > 0.15  
            and the mean, median and displays an histogram of outliers
   
            """ 

    parser = argparse.ArgumentParser(usage, version='%prog version 1.0', description=__doc__)

    parser.add_argument("-f", "--files", type=str, nargs='+',
                        help="Input file(s) to read(catalog)")
    parser.add_argument("-i", "--id", type=str, nargs='+', default=['ID'],
                        help="The name(s) of the ID column(s). If a single name is given, "
                             "it is used for all catalogs. (default: ID)")
    parser.add_argument("-s", "--specz", type=str, default='ZSPEC',
                        help="The name of the spectroscopic redshift column (default: ZSPEC)")
    parser.add_argument("-p", "--phz", type=str, default='Z',
                        help="The name of the photometric redshift column (default: Z)")
    parser.add_argument("-d", "--display", action="store_false", default=True,
                        help="Disables the plot window")
    parser.add_argument("-pdf", "--pdf", type=str, default='',
                        help="The FITS file with the 1D PDF")
    parser.add_argument("-samp", "--samp", action="store_true", default=False,
                        help="Enables communication with other SAMP applications")

    args = parser.parse_args()
            
    return args


    
################## MAIN ###########
if __name__ == '__main__':
            
    args = main()  

    ids = args.id
    if len(ids) == 1:
        ids = [ids[0]] * len(args.files)
    if len(ids) != len(args.files):
        print 'Wrong number of ID column names (must much the number of catalogs or 1)'
    
    # Read input files
    table, all_cols, orig_ids = create_table(args.files, ids, args.specz, args.phz)

    col_number = 2
    label = "PhotZ"
   
    (specZ, colZ, data, mean, median, sigma, mad, outliersPercent,sigmaNoOutliers, meanNoOutliers) = compute_stats(table, col_number)
        
    # Plot distribution
    if args.display:
            fig1 = displaySpeczPhotz(table['ID'], specZ, colZ, data)
            fig2 = displayHistogram(data, mean, median, mad, sigma, outliersPercent, sigmaNoOutliers, meanNoOutliers)
            samp = None
            if args.samp:
                samp = SampUpdater(args.files, ids, table, orig_ids, (fig1, fig2))
            selector = Selector((fig1, fig2, samp), table, all_cols, args.pdf)
            plt.show()
    
