/**
 * @file PhotometricCorrectionAlgorithm.icpp
 * @date January 14, 2015
 * @author Nikolaos Apostolakos
 */

#ifndef PHOTOMETRICCORRECTIONALGORITHM_ICPP
#define	PHOTOMETRICCORRECTIONALGORITHM_ICPP

#include <map>
#include <set>
#include "ElementsKernel/Exception.h"
#include "SourceCatalog/SourceAttributes/Photometry.h"
#include "PhzPhotometricCorrection/FindMedianPhotometricCorrectionsFunctor.h"

namespace Euclid {
namespace PhzPhotometricCorrection {

template <typename SourceIter, typename ModelPhotPtr>
static std::map<int64_t, PhzDataModel::PhotometricCorrectionMap> createSourcePhotCorrMap(
                                  SourceIter source, SourceIter source_end,
                                  const std::map<int64_t,double>& scale_factor_map,
                                  const std::map<int64_t, ModelPhotPtr>& model_phot_map) {

  // Iterate through the sources and calcualte their optimal photometric corerctions
  std::map<int64_t, PhzDataModel::PhotometricCorrectionMap> result {};
  for (; source != source_end; ++source) {

    // Get the source photometry
    auto source_phot_ptr = source->template getAttribute<SourceCatalog::Photometry>();
    if (source_phot_ptr == nullptr) {
      throw Elements::Exception() << "Source with ID " << source->getId()
          << " does not contain photometric information";
    }

    // Get the scale factor
    auto scale = scale_factor_map.find(source->getId());
    if (scale == scale_factor_map.end()) {
      throw Elements::Exception() << "Scale factor for source " << source->getId()
          << " is not available";
    }

    // Get the model photometry
    auto model_phot = model_phot_map.find(source->getId());
    if (model_phot == model_phot_map.end()) {
      throw Elements::Exception() << "Model photometry for source " << source->getId()
          << " is not available";
    }

    PhzDataModel::PhotometricCorrectionMap source_phot_corr {};
    auto source_iter = source_phot_ptr->begin();
    auto model_iter = model_phot->second->begin();
    for (;source_iter != source_phot_ptr->end(); ++source_iter, ++model_iter) {
      source_phot_corr[source_iter.filterName()] = scale->second * (*model_iter).flux / (*source_iter).flux;
    }
    result[source->getId()] = std::move(source_phot_corr);
  }
  return result;
}



template <typename SourceIter, typename ModelPhotPtr>
PhzDataModel::PhotometricCorrectionMap PhotometricCorrectionAlgorithm::operator ()(
                                  SourceIter source_begin, SourceIter source_end,
                                  const std::map<int64_t,double>& scale_factor_map,
                                  const std::map<int64_t, ModelPhotPtr>& model_phot_map,
                                  PCFunction<SourceIter> sss) {

  SourceIter alternate_begin(source_begin);
  // Check that we have some sources
  if (source_begin == source_end) {
    throw Elements::Exception() << "No sources given as input";
  }

  auto source_phot_corr_map = createSourcePhotCorrMap(source_begin, source_end,
                                                      scale_factor_map, model_phot_map);

  return sss(source_phot_corr_map, alternate_begin, source_end);
}

} // end of namespace PhzPhotometricCorrection
} // end of namespace Euclid

#endif	/* PHOTOMETRICCORRECTIONALGORITHM_ICPP */

